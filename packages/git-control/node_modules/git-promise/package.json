{
  "name": "git-promise",
  "description": "Simple wrapper to run any git command and process it's output using promises.",
  "version": "0.2.0",
  "homepage": "https://github.com/piuccio/git-promise",
  "author": {
    "name": "Fabio Crisci",
    "email": "piuccio@gmail.com"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/piuccio/git-promise.git"
  },
  "bugs": {
    "url": "https://github.com/piuccio/git-promise/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/piuccio/git-promise/blob/master/LICENSE"
    }
  ],
  "main": "./index.js",
  "engines": {
    "node": ">=0.10.0"
  },
  "scripts": {
    "test": "nodeunit test",
    "cover": "istanbul cover node_modules/nodeunit/bin/nodeunit -- test"
  },
  "keywords": [
    "git",
    "shell"
  ],
  "dependencies": {
    "q": "~1.0.1",
    "shelljs": "~0.3.0"
  },
  "devDependencies": {
    "nodeunit": "~0.8.6"
  },
  "readme": "# git-promise\r\n\r\nSimple wrapper that allows you to run any `git` command using a more intuitive syntax.\r\n\r\n## Getting Started\r\n\r\n```shell\r\nnpm install git-promise --save\r\n```\r\n\r\nOnce installed, you can use it in your JavaScript files like so:\r\n\r\n```js\r\nvar git = require(\"git-promise\");\r\n\r\ngit(\"rev-parse --abbrev-ref HEAD\").then(function (branch) {\r\n  console.log(branch); // This is your current branch\r\n});\r\n```\r\n\r\nThe module will handle exit code automatically, so\r\n\r\n```js\r\nvar git = require(\"git-promise\");\r\n\r\ngit(\"merge origin/master\").then(function () {\r\n  // Everything was fine\r\n}).fail(function (err) {\r\n  // Something went bad, maybe merge conflict?\r\n  console.error(err);\r\n});\r\n```\r\n\r\n## Advanced usage\r\n\r\nThe `git` command accepts a second parameter that can be used to parse the output or to deal with non 0 exit code.\r\n\r\n```js\r\nvar git = require(\"git-promise\");\r\n\r\ngit(\"status -sb\", function (stdout) {\r\n  return stdout.match(/## (.*)/)[1];\r\n}).then(function (branch) {\r\n  console.log(branch); // This is your current branch\r\n});\r\n```\r\n\r\nThe callback accepts 2 parameters, `(stdout, code)`, where `stdout` is the output of the git command and `code` is the exit code.\r\n\r\nThe return value of this function will be the resolved value of the promise.\r\n\r\nIf the `code` parameter is not specified, it'll be handled automatically and the promise will be rejected in case of non 0 code.\r\n\r\n```js\r\nvar git = require(\"git-promise\");\r\n\r\ngit(\"merge-base --is-ancestor master HEAD\", function (stdout, code) {\r\n  if (code === 0) {\r\n    // the branch we are on is fast forward to master\r\n    return true;\r\n  } else if (code === 1) {\r\n    // no, it's not\r\n    return false;\r\n  } else {\r\n    // some other error happened\r\n    throw new Error(\"Something bad happened: \" + stdout);\r\n  }\r\n}).then(function (isFastForward) {\r\n  console.log(isFastForward);\r\n}).fail(function (err) {\r\n  // deal with the error\r\n});\r\n```\r\n\r\n\r\n### Chaining commands\r\n\r\nImagine to be on a local branch which is not fast forward with master and you want to know which commit were pushed on master after the forking point:\r\n\r\n```js\r\nvar git = require(\"git-promise\");\r\n\r\nfunction findForkCommit () {\r\n  return git(\"merge-base master HEAD\", function (output) {\r\n    return output.trim();\r\n  });\r\n}\r\n\r\nfunction findChanges (forkCommit) {\r\n  return git(\"log \" + forkCommit + \"..master --format=oneline\", function (output) {\r\n    return output.trim().split(\"\\n\");\r\n  });\r\n}\r\n\r\n// synchronization can be done in many ways, for instance with Q\r\nvar Q = require(\"q\");\r\n[findForkCommit, findChanges].reduce(Q.when, Q({})).then(function (commits) {\r\n  console.log(commits);\r\n});\r\n\r\n// or simply using promises, simple cases only?\r\nfindForkCommit().then(findChanges).then(function (commits) {\r\n  console.log(commits);\r\n});\r\n```\r\n\r\n### Working directory\r\n\r\nBy default all git commands run in the current working directory (i.e. `process.cwd()`).\r\n\r\nYou can use the following syntax to run a git command in different folder\r\n\r\n```js\r\nvar git = require(\"git-promise\");\r\n\r\ngit(\"blame file1.js\", {cwd: \"src/\"}).then(function () {\r\n  // Blame someone\r\n});\r\n```\r\n\r\n## Utility methods\r\n\r\nThis module comes with some utility methods to parse the output of some git commands\r\n\r\n```js\r\nvar util = require(\"git-promise/util\");\r\n```\r\n\r\n* `util.extractStatus(output [, lineSeparator])`\r\n\r\nParse the output of `git status --procelain` and returns an object with\r\n\r\n```\r\n{\r\n  branch: \"current branch name, only if git status -b is used\",\r\n  index: {\r\n    modified: [\"list of files modified in the index\"],\r\n    added: [\"list of files added in the index\"],\r\n    deleted: [\"list of files deleted in the index\"],\r\n    renamed: [\"list of files renamed in the index\"],\r\n    copied: [\"list of files copied in the index\"]\r\n  },\r\n  workingTree: {\r\n    modified: [\"list of files modified in the local working tree\"],\r\n    added: [\"list of files added / renamed / copied in the local working tree\"],\r\n    deleted: [\"list of files deleted in the local working tree\"]\r\n  }\r\n}\r\n```\r\n\r\nThe method works both with or without option `-z`.\r\n\r\n* `util.hasConflict(output)`\r\n\r\nTry to determine if there's a merge conflict from the output of `git merge-tree`\r\n\r\n```js\r\nvar git = require(\"git-promise\");\r\nvar util = require(\"git-promise/util\");\r\n\r\ngit(\"merge-tree <root-commit> <branch1> <branch2>\").then(function (stdout) {\r\n  console.log(util.hasConflict(stdout));\r\n});\r\n```\r\n\r\n## Release History\r\n\r\n* 0.2.0 Change current working directory\r\n* 0.1.0 Just started\r\n",
  "readmeFilename": "README.md",
  "_id": "git-promise@0.2.0",
  "_from": "git-promise@^0.2.0"
}
