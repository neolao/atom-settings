<?xml version='1.0' encoding='UTF-8' ?>
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.1//EN' 'http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd'>
<html xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'>
    <head>
        <title>Explaining the DOM</title>
        <meta content="width=device-width, initial-scale=1" name="viewport"/>
        <meta content="index, follow" name="robots"/>
        <meta content="Austin Cheney" name="author"/>
        <meta content="Global" name="distribution"/>
        <meta content="en" http-equiv="Content-Language"/>
        <meta content="application/xhtml+xml;charset=UTF-8" http-equiv="Content-Type"/>
        <meta content="blendTrans(Duration=0)" http-equiv="Page-Enter"/>
        <meta content="blendTrans(Duration=0)" http-equiv="Page-Exit"/>
        <meta content="text/css" http-equiv="content-style-type"/>
        <meta content="application/javascript" http-equiv="content-script-type"/>
        <style type="text/css">
            body {
                background: #fff;
                color: #000;
                font-family: sans-serif;
                font-size: 10px;
                width: 80em;
            }
            h1,
            h2,
            h3,
            h4,
            h5,
            h6 {
                font-weight: bold;
                margin: 1em 0em 0em;
            }
            h1 {
                color: #600;
                font-size: 2.75em;
                margin-bottom: 1em;
            }
            h1 span {
                font-size: 0.5em;
            }
            h2 {
                color: #711;
                font-size: 2.25em;
            }
            h3 {
                color: #822;
                font-size: 2em;
            }
            h4 {
                color: #933;
                font-size: 1.25em;
            }
            h5 {
                color: #a44;
                font-size: 1.25em;
            }
            h6 {
                color: #b55;
                font-size: 1.1em;
            }
            li {
                margin: 1em 0em 0em;
            }
            p {
                font-size: 1.5em;
                line-height: 1.2;
                margin: 1em 0em 0em;
            }
            div {
                padding-left: 1.5em;
            }
            a {
                color: #c00;
                font-weight: bold;
            }
            .code {}
            .code em {
                font-size: 1.5em;
                font-style: normal;
            }
            #toc li {
                font-size: 1.4em;
            }
            #toc li li {
                font-size: 0.9em;
            }
            #access li p {
                margin: 1em 0em;
            }
            #access .example {
                color: #060;
                font-family: monospace;
                font-size: 1.2em;
                font-weight: bold;
                margin: 0em;
            }
            #access .example span {
                color: #999;
                font-weight: normal;
            }
        </style>
    </head>
    <body>
        <h1>The DOM Explained,
            <span>Quick and Simple</span></h1>
        <p>By
            <a href="http://prettydiff.com/">Austin Cheney</a>, 26 July 2014</p>
        <div id="toc">
            <h2>Table of Contents</h2>
            <ul>
                <li><a href="#intro">Introduction</a>
                    <ul>
                        <li><a href="#intro-scope">Scope of this Document</a></li>
                        <li><a href="#intro-domis">What the DOM Is</a></li>
                    </ul>
                </li>
                <li><a href="#history">History of the DOM</a></li>
                <li><a href="#define">How HTML Loads in Modern Browsers</a></li>
                <li><a href="#access">Accessing the DOM in JavaScript</a>
                    <ul>
                        <li><a href="#access-search">Methods for Searching the DOM</a></li>
                        <li><a href="#access-walking">Walking the DOM</a></li>
                        <li><a href="#access-changing">Changing the DOM</a></li>
                    </ul>
                </li>
            </ul>
        </div>
        <div id="intro">
            <h2>Introduction</h2>
            <div id="intro-scope">
                <h3>Scope of this Document</h3>
                <p>This document will only focus upon DOM Level 2. Although DOM Level 1
                    is still universally supported this document views it as an expired and
                    purely legacy artifact. XML namespaces and event execution, as well its
                    memory management, will not be discussed thereby negating need to dwell
                    of DOM Level 3 and 4.</p>
                <p>This document is an attempt to explain what the DOM is, how to use
                    it, and why it is defined the way it is. The intended audience is
                    anybody wanting to enrich their understanding of the DOM. Although the
                    DOM is language agnostic this document is writing from the perspective
                    of JavaScript.</p>
                <p>This is not a
                    <em>how to</em>
                    article. This document does not discuss abstractions, frameworks, or
                    other helpers. This document seeks to be educational, which is to say
                    this document seeks to explain things. This document does not attempt to
                    provide tools or suggestions.</p>
            </div>
            <div id="intro-domis">
                <h3>What the DOM Is</h3>
                <p>The DOM serves primarily as an API for JavaScript to access and
                    interpret any markup language based upon the XML syntax, which still
                    includes HTML. It is language agnostic so that it can be used and
                    defined by a variety of languages in a variety of ways. As expressed in
                    JavaScript, the DOM is a collection of objects that inherit from a
                    master object named:
                    <em>document</em>. Each data facet conveyed by the DOM is an object. The
                    inheritance and relationships naturally demonstrated through the
                    document structure of the markup (functional inheritance) is defined in
                    the DOM through methods inherited from the document object.</p>
                <p>It is important to recognize the DOM is the standard way that web
                    browsers interact with HTML. Every JavaScript framework, library, and
                    abstraction that accesses the DOM ultimately does so through the
                    standard DOM methods. A proper understanding of the DOM is critical for
                    accessibility, performance, semantics, and basic problem solving.</p>
                <p>Every data facet expressed by the DOM is referred to as a
                    <em>node</em>. Every node is defined of one of
                    <a href="http://www.w3.org/TR/DOM-Level-2-Core/core.html">twelve
                        types</a>.
                    Only the types: element, text, and attribute are commonly used in the
                    web though every type is available in modern web browsers. The objects
                    representative of the nodes feature properties that define their
                    relationships or inherit methods that can define their relationships,
                    such as the parentNode property.</p>
                <p>Because DOM Level 2, and later versions, are based upon XML syntax
                    the DOM is case-sensitive. When accessing HTML, which is not
                    case-sensitive, case-sensitivity can vary browser and browser version.
                    It is recommended to always use lower case to access HTML from the DOM
                    to eliminate minor conformance differences by browser and also force
                    HTML elements and attribute names to lower case when interpreting names
                    returned from the DOM.</p>
                <p>There is a standard alternative to the DOM with a lighter memory
                    footprint and arguably far faster execution time called XPath.
                    Unfortunately, XPath is not universally supported as native access
                    method. This further reinforces the importance of learning the DOM as
                    the only universally supported and standard API to access a markup
                    document structure.</p>
                <p>The well known
                    <em>innerHTML</em>
                    and 
                    <em>outerHTML</em>
                    properties are not defined in the DOM. As such they will not be discussed
                    here.</p>
            </div>
        </div>
        <div id="history">
            <h2>History of the DOM</h2>
            <p>The DOM originally came about as a standard means for accessing HTML
                from JavaScript. Prior to the first DOM standard IE and Netscape had
                separate and unrelated means of accessing HTML. The first standard is
                the original
                <a href="http://www.w3.org/TR/REC-DOM-Level-1/">DOM Specification</a>,
                later called DOM Level 1, from 1997. There was an immediate and vital
                need for conformity so this document was released earlier than other
                <a href="http://w3.org/">W3C</a>
                technologies.</p>
            <p>In 1998 work began on the
                <a href="http://www.w3.org/TR/DOM-Level-2-Core/">DOM Level 2</a>
                specification that became a recommendation in late 2000. If you compare
                the proposed properties of the Level 2 document to the Level 1 document
                you can see there are wild differences. For instance DOM Level 1
                identifies properties directly related to tags required in HTML while
                DOM Level 2 is fully language agnostic. The DOM Level 2 specification
                was written in parallel with the
                <a href="http://www.w3.org/TR/xmlschema-1/">XML Schema Part 1:
                    Structures</a>
                specification. DOM Level 2 specification released revisions shortly after
                each XML specification revision and became a formal recommendation only
                after XML Schema became a recommendation. DOM Level 2 is primarily
                concerned with node definitions, node types, and access to nodes via
                their relationships.</p>
            <p>In 2004 the
                <a href="http://www.w3.org/TR/DOM-Level-3-Core/">DOM Level 3
                    specification</a>
                became a recommendation on the same date DOM Level 2 received its final
                update. This was also just three weeks after a major revision to the
                <a href="http://www.w3.org/TR/2004/PER-xmlschema-1-20040318/">XML Schema
                    Part 1 Second Edition Edit Recommendation</a>
                was released. Notice that DOM Level 3 extends DOM Level 2 but does not
                extend DOM Level 1. DOM Level 3 is primarily concerned with namespaces,
                inheritance, and extension of node names and definitions.</p>
            <p>At this time
                <a href="http://www.w3.org/TR/dom/">DOM Level 4</a>
                is nearing final review. DOM Level 4 is worthy of note in that it extends
                DOM Level 2 and 3 but is focused primarily upon interaction and events
                instead of anything related to structure or node relationships. A
                primary example is that
                <em>garbage collection</em>
                is described in the specification where in the past these discussions
                were left entirely to the implementation of JavaScript interpreters. In
                a purely desktop driven experience DOM Level 4 might be considered
                unnecessarily and excessive. New platforms like mobile and tablets have
                proven that standard definitions for events and interaction is not
                enough. There must also be standard guidance on implementation of those
                events to achieve conformance, such as when the two largest mobile
                platform developers cannot produce interfaces that execute to the
                standards they helped write.</p>
        </div>
        <div id="define">
            <h2>How HTML Loads in Modern Browsers</h2>
            <p>It is important to understand how the DOM is created. If a cached
                JavaScript file is requested at the top of a document and is well
                written it is quite possible that it may request access to the DOM
                before objects of the DOM are created, which can result in unintended
                errors. For performance reasons it is often suggested that JavaScript be
                requested from the bottom of a document, which also provides the benefit
                of allowing the DOM to fully render before attempts to access it are
                executed.</p>
            <p>The first thing modern browsers do when encountering any markup
                language, such as HTML, is parse the markup. Parsing does not imply
                producing or rendering the DOM, which is a separate and later process.
                All modern documents use XML as a parsing foundation for any XML similar
                markup languages, which includes not well formed HTML. Because XML
                provides syntax rules that are terse and specific writing an XML parser
                is much faster, easier, and cheaper than writing an HTML parser. This
                means a smaller and faster executing parser, but more importantly it
                means a solid foundation on which to provide additional rules necessary
                for parsing HTML. An example of standard parsing guidance can be found
                in the
                <a href="http://www.w3.org/TR/xml-infoset/">XML Information Set</a>.</p>
            <p>Once the markup is parsed requests for additional resources are
                identified and those requests are executed. It is absolutely essential
                that the requests for additional resources execute as immediately as
                possible as the transmission time necessary to return these resources
                can occur simultaneously to the DOM rendering. For performance it is
                considered a good idea to put requests for visual artifacts,
                particularly stylesheets, as high in the document as possible so that
                the page can render visually as the DOM renders without repainting
                later. Another reason the DOM is created separate from the parsing
                process is because it is significantly larger, and thus slower to
                produce and populate into memory, than the parse data.</p>
            <p>After the DOM is fully rendered, all requests for additional
                resources have executed, and all initially requested JavaScript is
                interpreted the load of the page is complete. It is only at this time
                that the
                <em>onload</em>
                executes. It is important to take note that older versions of Internet
                Explorer require receipt of an HTTP response for all requested
                resources, which means that if an HTTP response is never returned the
                onload event never executes. It is also important to notice that
                requests for JavaScript not made from the HTML have no bearing on the
                execution of the onload event and neither do any JavaScript executions
                that occur outside of initial interpretation or through any other
                API.</p>
        </div>
        <div id="access">
            <h2>Accessing the DOM in JavaScript</h2>
            <div id="access-search">
                <h3>Methods for Searching the DOM</h3>
                <p>The DOM is searched using methods defined on the
                    <em>document</em>
                    object. Some methods defined in that object are inherited by other DOM
                    objects and some methods are not. Any DOM access method executed on the
                    document object search from the
                    <em>document.documentElement</em>
                    object that represents the root node of the markup, typically the
                    <em>&lt;html&gt;</em>
                    element. The most common methods for accessing the DOM are:</p>
                <ul>
                    <li>
                        <h4 class="code"><em>getElementById</em>
                            - DOM Level 2</h4>
                        <p>This method is only available from the document object or
                            documentFragment type object and requires a string argument. The method
                            will search the document for the first node with an
                            <em>id</em>
                            attribute whose value matches the value of the provided string argument.
                            This method returns either null or the first DOM element node with a
                            matching ID attribute value.</p>
                        <p class="example">document.getElementById("idValue");
                            <span>//returns null or element node</span></p>
                    </li>
                    <li>
                        <h4 class="code"><em>getElementsByTagName</em>
                            - DOM Level 2</h4>
                        <p>This method is inherited to all element node types and requires a
                            string argument. This method will search from the object it is executed
                            on for all elements with a tag name matching the provided string. A node
                            list is always returned. If there are no matching elements a node list
                            with 0 indexes is returned.</p>
                        <p class="example">document.getElementsByTagName("div");
                            <span>//returns a node list</span></p>
                        <p class="example">myElementNode.getElementsByTagName("div");<span>//returns
                            a node list</span></p>
                    </li>
                    <li>
                        <h4 class="code"><em>getElementsByClassName</em>
                            - DOM Level 4</h4>
                        <p>This method is inherited to all element node types and requires a
                            string argument. This method will search from the object it is executed
                            on for all elements with a class attribute value matching any class name
                            in the class attribute of any element. Class names are represented as a
                            space separated list in the class attribute value. A node list is always
                            returned. If there are no matching elements a node list with 0 indexes
                            is returned.</p>
                        <p class="example">document.getElementsByClassName("classValueToken");
                            <span>//returns a node list</span></p>
                        <p class="example">myElementNode.getElementsByClassName("classValueToken");
                            <span>//returns a node list</span></p>
                    </li>
                    <li>
                        <h4 class="code"><em>getAttribute</em>
                            - DOM Level 2</h4>
                        <p>This method is inherited to all element node types and requires a
                            string argument. This method will return the string value of the
                            attribute matching the attribute name supplied in the string argument.
                            If no matching attribute exists it will return null.</p>
                        <p class="example">myElementNode.getAttribute("attributeName");
                            <span>//returns null or a string</span></p>
                    </li>
                    <li>
                        <h4 class="code"><em>cloneNode</em>
                            - DOM Level 2</h4>
                        <p>This method is inherited to all DOM nodes. If this method is used on
                            an element node all values, attributes, and properties are cloned. This
                            method takes one argument of type boolean, which if true also clones all
                            child and descendant nodes.</p>
                        <p class="example">myNode.cloneNode(true);
                            <span>//returns a copy of a node including all descendants</span></p>
                        <p class="example">myNode.cloneNode();
                            <span>//returns a copy of a node not including descendants</span></p>
                    </li>
                </ul>
            </div>
            <div id="access-walking">
                <h3>Walking the DOM</h3>
                <p>Another means of accessing the DOM is by starting from a DOM element
                    node and moving from node to node using relationships defined in the
                    properties of each element's DOM object. This is called
                    <em>walking the DOM</em>. Here are a list of the most common properties
                    to demonstrate those relationships:</p>
                <ul>
                    <li>
                        <h4 class="code"><em>parentNode</em>
                            - DOM Level 2</h4>
                        <p>The parentNode property is available to every DOM node regardless of
                            node type. This property returns the element node immediately containing
                            the current DOM node. When the parentNode property is executed on the
                            document.documentElement object the document object is returned.</p>
                        <p class="example">myNode.parentNode;
                            <span>//returns an element node</span></p>
                    </li>
                    <li>
                        <h4 class="code"><em>childNodes</em>
                            - DOM Level 2</h4>
                        <p>The childNodes property is available to every element node type. When
                            executed this property will return a node list of child nodes regardless
                            of type, but it will not return descendant nodes, which are nodes that
                            are children of the immediate child nodes. The child nodes are always
                            returned in the same order in which they occur in the DOM. Versions of
                            Internet Explorer 8, and earlier, intentionally omitted text nodes
                            containing only white space characters from the childNodes property
                            thereby creating conformance problems. The childNodes property does not
                            return attribute nodes.</p>
                        <p class="example">myElementNode.childNodes;
                            <span>//returns a node list</span></p>
                    </li>
                    <li>
                        <h4 class="code"><em>firstChild</em>
                            - DOM Level 2</h4>
                        <p>The firstChild property is available to all element, document, and
                            documentFragment node types. It returns the first child node from the
                            childNodes node list. If this property is executed on the document
                            element it will return a documentType node type.</p>
                        <p class="example">myElementNode.firstChild;
                            <span>//returns first child node</span></p>
                    </li>
                    <li>
                        <h4 class="code"><em>lastChild</em>
                            - DOM Level 2</h4>
                        <p>This property returns the node in position:
                            childNodes[childNodes.lenght - 1], but is otherwise identical to the
                            firstChild property.</p>
                        <p class="example">myElementNode.lastChild;
                            <span>//returns last child node</span></p>
                    </li>
                    <li>
                        <h4 class="code"><em>nextSibling</em>
                            - DOM Level 2</h4>
                        <p>The nextSibling property is available to every DOM node and returns
                            the next child element of the parent node. If the current node is the
                            last child of its parent this property will return null.</p>
                        <p class="example">myNode.nextSibling;
                            <span>//returns next adjacent node</span></p>
                    </li>
                    <li>
                        <h4 class="code"><em>previousSibling</em>
                            - DOM Level 2</h4>
                        <p>The perviousSibling property is available to every DOM node and
                            returns the previous child element of the parent node. If the current
                            node is the first child of its parent this property will return
                            null.</p>
                        <p class="example">myNode.nextSibling;
                            <span>//returns prior adjacent node</span></p>
                    </li>
                    <li>
                        <h4 class="code"><em>attributes</em>
                            - DOM Level 3</h4>
                        <p>The attributes property is only available to element type nodes. It
                            returns a node list of all attributes, as well as their values,
                            represented on that element. If an element has no attributes then a list
                            of length 0 is returned.</p>
                        <p class="example">myElementNode.attributes;
                            <span>//returns a node list of format: attributeName="value"</span></p>
                    </li>
                    <li>
                        <h4 class="code"><em>nodeType</em>
                            - DOM Level 2</h4>
                        <p>This property is available to every DOM node. It always returns a
                            number depend upon the node type as described in the following list
                            order.</p>
                        <ol>
                            <li>ELEMENT_NODE</li>
                            <li>ATTRIBUTE_NODE</li>
                            <li>TEXT_NODE</li>
                            <li>CDATA_SECTION_NODE</li>
                            <li>ENTITY_REFERENCE_NODE</li>
                            <li>ENTITY_NODE</li>
                            <li>PROCESSING_INSTRUCTION_NODE</li>
                            <li>COMMENT_NODE</li>
                            <li>DOCUMENT_NODE</li>
                            <li>DOCUMENT_TYPE_NODE</li>
                            <li>DOCUMENT_FRAGMENT_NODE</li>
                            <li>NOTATION_NODE</li>
                        </ol>
                        <p class="example">myNode.nodeType;
                            <span>//returns a number 1 - 12</span></p>
                    </li>
                    <li>
                        <h4 class="code"><em>nodeName</em>
                            - DOM Level 2</h4>
                        <p>This property always returns either a string or null depending upon
                            the node type. Please see this
                            <a href="http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-1841493061">table
                                in the specification</a>
                            for value definitions. According to conformance with the XML
                            specification the value returned this property should always be case
                            sensitive and specifically match the node it is applied against. With
                            HTML, however, this is frequently not the case and differs by browser
                            and version. I recommend always using the JavaScript
                            <em>toLowerCase</em>
                            against the value returned for nodeType to safely force conformity.</p>
                        <p class="example">myNode.nodeName;
                            <span>//returns a string of variant definition by node type</span></p>
                    </li>
                    <li>
                        <h4 class="code"><em>nodeValue</em>
                            - DOM Level 2</h4>
                        <p>This property always returns either a string or null depending upon
                            the node type. Please see this
                            <a href="http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-1841493061">table
                                in the specification</a>
                            for value definitions.</p>
                        <p class="example">myNode.nodeValue;
                            <span>//returns either null for a string of variant definition by node
                                type</span></p>
                    </li>
                </ul>
            </div>
            <div id="access-changing">
                <h3>Changing the DOM</h3>
                <p>The DOM can also be manipulated and altered through various means.
                    The following is a list of common means to change the DOM:</p>
                <ul>
                    <li>
                        <h4 class="code"><em>createElement</em>
                            - DOM Level 2</h4>
                        <p>The createElement method is available from the document object or a
                            documentFragment type object and takes a single string argument. The
                            value of the string argument is the name of an element type node to
                            create, so this method will throw an error if the supplied string
                            violates syntax rules for element names.</p>
                        <p class="example">document.createElement("div");
                            <span>//returns a new element node not bound to the document</span></p>
                    </li>
                    <li>
                        <h4 class="code"><em>createTextNode</em>
                            - DOM Level 2</h4>
                        <p>The createTextNode method is available from the document object or a
                            documentFragment type object and takes a single string argument. The
                            value of the string argument is the text content of the node.</p>
                        <p class="example">document.createTextNode("some text here");
                            <span>//returns a new text node not bound to the document</span></p>
                    </li>
                    <li>
                        <h4 class="code"><em>appendChild</em>
                            - DOM Level 2</h4>
                        <p>This method is available to every element type node. It takes a
                            single argument of a reference to a node object, which is an object node
                            to add to the DOM, and adds this node after every other child node. The
                            object node must not already have an assigned parent node.</p>
                        <p class="example">myElementNode.appendChild(newNode);
                            <span>//returns the appended node</span></p>
                    </li>
                    <li>
                        <h4 class="code"><em>insertBefore</em>
                            - DOM Level 2</h4>
                        <p>This method is available to every element type node. It takes a two
                            arguments which is a reference node and a reference to a new node
                            object, adds this new node before the reference node. The object node
                            must not already have an assigned parent node.</p>
                        <p class="example">myElementNode.insertBefore(referenceNode, newNode);
                            <span>//returns the newNode</span></p>
                    </li>
                    <li>
                        <h4 class="code"><em>removeChild</em>
                            - DOM Level 2</h4>
                        <p>This method is available to every element type node. It takes a
                            single argument of a reference to a node object, which must be a child
                            node of the current node. The supplied node is removed from its parent
                            node and so it is effectively removed from the document. As long as the
                            JavaScript reference to this node can still be accessed the node will
                            remain alive in memory so that it can be changed and added back to the
                            document later.</p>
                        <p class="example">myElementNode.removeChild(anotherNode);
                            <span>//returns anotherNode</span></p>
                        <p class="example">myElementNode.removeChild(myElementNode.lastChild);
                            <span>//returns myElementNode.lastChild</span></p>
                        <p class="example">myElementNode.removeChild(myElementNode.childNodes[3]);
                            <span>//returns myElementNode.childNodes[3]</span></p>
                    </li>
                    <li>
                        <h4 class="code"><em>replaceChild</em>
                            - DOM Level 2</h4>
                        <p>This method is available to every element type node. It takes a two
                            arguments. The first is a new DOM node and the second is a DOM node to
                            replace. The new DOM node cannot have an assigned parentNode and the old
                            DOM node will have its parentNode unassigned effectively removing it
                            from the document. The old DOM node will continue to reside in memory so
                            long as a variable reference to it remains available.</p>
                        <p class="example">myElementNode.replaceChild(newNode, originalNode);
                            <span>//returns originalNode</span></p>
                    </li>
                    <li>
                        <h4 class="code"><em>removeAttribute</em>
                            - DOM Level 2</h4>
                        <p>This method is available to every element type node. It takes a
                            single argument representing an attribute name and if that attribute
                            exists it is removed from its parent element.</p>
                        <p class="example">myElementNode.removeAttribute("class");
                            <span>//returns nothing</span></p>
                    </li>
                    <li>
                        <h4 class="code"><em>setAttribute</em>
                            - DOM Level 2</h4>
                        <p>This method is available to every element type node. It takes two
                            arguments of which both are strings. The first argument is the name of
                            the attribute and the second argument is the value to assign. If an
                            attribute with that name already exists it will be over written
                            otherwise a new attribute will be created.</p>
                        <p class="example">myElementNode.removeAttribute("class",
                            "myAttributeValue");
                            <span>//returns nothing</span></p>
                    </li>
                </ul>
            </div>
        </div>
    </body>
</html>